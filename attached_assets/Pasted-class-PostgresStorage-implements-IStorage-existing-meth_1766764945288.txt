class PostgresStorage implements IStorage {
  // ... existing methods ...
  
  async getUserByEmail(email: string): Promise<User | undefined> {
    try {
      const [user] = await db
        .select()
        .from(users)
        .where(eq(users.email, email))
        .limit(1);
      return user;
    } catch (error) {
      console.error('Error fetching user by email:', error);
      return undefined;
    }
  }
  
  async getUserByUsernameOrEmail(usernameOrEmail: string): Promise<User | undefined> {
    try {
      const [user] = await db
        .select()
        .from(users)
        .where(
          or(
            eq(users.username, usernameOrEmail),
            eq(users.email, usernameOrEmail)
          )
        )
        .limit(1);
      return user;
    } catch (error) {
      console.error('Error fetching user:', error);
      return undefined;
    }
  }
  
  async updateUserLastLogin(id: string): Promise<void> {
    try {
      await db
        .update(users)
        .set({ 
          last_login: new Date(),
          updatedAt: new Date()
        })
        .where(eq(users.id, id));
    } catch (error) {
      console.error('Error updating last login:', error);
    }
  }
  
  async createUserWithHash(data: {
    username: string;
    email: string;
    password_hash: string;
    fullName?: string;
    role?: string;
  }): Promise<User> {
    try {
      const [user] = await db
        .insert(users)
        .values({
          username: data.username,
          email: data.email,
          password_hash: data.password_hash,
          fullName: data.fullName,
          role: data.role || 'user',
          is_active: true,
          email_verified: false,
        })
        .returning();
      return user;
    } catch (error) {
      console.error('Error creating user:', error);
      throw error;
    }
  }
  
  async deactivateUser(id: string): Promise<boolean> {
    try {
      const [updated] = await db
        .update(users)
        .set({ is_active: false, updatedAt: new Date() })
        .where(eq(users.id, id))
        .returning();
      return !!updated;
    } catch (error) {
      console.error('Error deactivating user:', error);
      return false;
    }
  }
  
  async activateUser(id: string): Promise<boolean> {
    try {
      const [updated] = await db
        .update(users)
        .set({ is_active: true, updatedAt: new Date() })
        .where(eq(users.id, id))
        .returning();
      return !!updated;
    } catch (error) {
      console.error('Error activating user:', error);
      return false;
    }
  }
  
  async getAllUsers(): Promise<User[]> {
    try {
      return await db
        .select()
        .from(users)
        .orderBy(desc(users.createdAt));
    } catch (error) {
      console.error('Error fetching all users:', error);
      return [];
    }
  }
  
  async getUserCount(): Promise<number> {
    try {
      const [result] = await db
        .select({ count: count() })
        .from(users);
      return result?.count || 0;
    } catch (error) {
      console.error('Error counting users:', error);
      return 0;
    }
  }
  
  // ... rest of existing methods ...
}